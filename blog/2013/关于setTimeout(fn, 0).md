关于setTimeout(fn, 0)
=====================


故事背景
--------
>故事发生在很久很久以前，当我还是一个小前端的时候。。。

_路人甲：~!@#$%^&* ... !!!_  

好吧，不废话，入正题。  


主题背景
--------
好不容易有思路实现了 [失焦自动隐藏](http://192.168.5.121/blog/autoPublish/strapdownAuto.html?file=%E5%A4%B1%E7%84%A6%E8%87%AA%E5%8A%A8%E9%9A%90%E8%97%8F%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88&license=cc) 事件，在测试时却被这样的特性整了。  
测试页面几经改版，功能已经很齐全了，用户体验方面一直在上台阶。下面请看历史版本

* 自己随便测试的版本，只有一个按钮，按一下弹出对话框，点击关闭按钮关闭对话框。需要鼠标来回移动 查看测试结果，很不方便
* 挂到个人主页 [最近更新](http://192.168.5.121/effect/bangli/sns/blDialog/7-8/0.1/popupDialog.html) 上，不能这么粗糙了，遂改进了一下。按回车可以 **显示** / **隐藏** 对话框。比起鼠标来回不停地动，键盘操作显然方便很多了，左右手都可以同时操作。  
也正是这个体验改进，发现了一个很严重的bug：代码中，将 *阻止浏览器默认行为* 的语句，放在了 `closeHandle` 方法里，使这个方法始终返回false，导致 `destroy`销毁一直失败。虽然页面上没有什么影响，但是每次生成的对话框都没有销毁，有内存泄露的风险。
* [7-9版本](http://192.168.5.121/effect/bangli/sns/blDialog/7-9/0.1/popupDialog.html) ，由于新增了九种设置，导致简单的div界面比较难看，所以用 `fieldset` 重新组织了页面，并稍微加了浅白色背景，使文字更容易分辨。  
功能方面，新增了空格键实时预览（因为之前要按两次回车键，才能看到最新结果）。后来，根据 `雪儿` 同事的建议，直接监听 `select` 和 `checkbox` 的 `change` 事件，实时预览效果更加顺畅。
* [7-10版本](http://192.168.5.121/effect/bangli/sns/blDialog/7-10/0.1/popupDialog.html) ，增加了遮罩层设置、关闭按钮设置、失焦自动隐藏设置。  
问题来了， **实时预览效果** 与 **失焦自动隐藏** 事件产生冲突。


现场回放
--------
针对 **7-10版本** ，说明一下冲突原因：由于设置了 **失焦自动隐藏** ，所以点击对话框外的范围，会自动隐藏对话框。  
然后，测试页面在 `select` 的 `change` 事件里，生成并显示了对话框。  
但是，事还没完，生成了对话框之后， **浏览器还接着触发** 了 `select` 的 `click` 事件，导致 **意外触发** 了新对话框的 **失焦自动隐藏事件** 。  

缕一遍：`onchange` -> `new dialog().show()` -> `onclick` -> `dialog.blurHide()` 。  
所以，不管怎么选下拉选项，对话框都无法出现（而键盘事件依然可以显示对话框），即  **实时预览效果** 与 **失焦自动隐藏** 事件产生冲突。


解决方案
--------
好了，在了解原理的基础上，可以继续朝着这个方向折腾了。下面是失败的方案：

* 在 `change` 事件里，阻止事件冒泡。无效！因为，是这个事件结束后接着产生的 `click` 事件 坏了事。跟 `change` 事件无关。
* 那改用 `option` 呢？其实我也不知道 `option` 在页面的什么地方，因为 `click` 、 `mousedown` 、 `mousemove` 都对 `select选项` 不管用。。。
* `select` 的 `mousemove` 事件呢？做起来怪怪的，如果最后没有什么好的方案，就凑合它吧。

嗯，尝试了这么多失败的方案，总算是体会到了 *方向不对，努力白费* 。马上回头，不纠结各种事件，而是要抓住罪魁祸首： **事件链** ！  
既然 `onchang` 之后还触发了 `onclick` 事件，那有没有什么办法能在 `onclick` 事件之后再执行 `onchang` 事件的代码呢？  
没错， `setTimeout` ！延迟就对了。遂在 `onchange` 事件里，用 `setTimeout` “包裹”了关键代码，设置 `10` 毫秒延迟，然后 `Ctrl+s` 、 `Alt+Tab` 、 `F5` ，开始测试！  
点个下拉框，改变选项，耶，对话框华丽丽地出现了。心中暗喜，不过还不是高潮。回到代码，不知哪来的灵感，手贱贱地把 `10` 毫秒改为 `0` 。再次潇洒地测试，对话框还是很乖地弹了出来。  

好，至此，实验结束。


结论
----
由于js是单线程操作，所以在事件的传递过程中，程序会一直挂起，而 `setTimeout` 等模拟的定时方法，其实不是真的另起了一个线程处理，而是在主线程空闲时，反复循环算算时间，“感觉”差不多了就执行其中的代码。  
所以在事件的传递过程中（比如 `click = mousedown + mouseup` ），即使 `setTimeout` 设置为 `0` ，也会等到整个事件链结束之后，才调用其中设定的代码。

建议：不要轻易使用这个特性，尽量换其它替代方案，除非你很擅长这个，而且确信未来不会有 多线程处理js 的浏览器。


吐吐槽
------
说下这几天做对话框，最耽误事的几个点：

* 回车键 toggle 响应
* 关闭按钮的文本、背景图设置的优先级，鼠标悬浮处理等（规则比较复杂，已经在测试页面的 **关闭按钮普通背景** 节点附近，写了html注释，通过源文件可以看到）
* 关闭按钮事件 的测试代码
* **实时预览效果** 与 **失焦自动隐藏** 事件的冲突

还有，为什么说最耽误事呢？因为都是下班之后，弄了三四个小时才弄好的。。。
